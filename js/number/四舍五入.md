
toFixed() 方法在进行四舍五入时可能会产生一些不准确的结果，这是因为 toFixed() 方法在处理浮点数时，实际上使用的是舍入到最近的偶数（银行家舍入）策略，而不是标准的四舍五入。这种舍入策略是为了在大量运算时减小累积误差。

toFixed只能给数字类型用

let a = '123.345'
Number(a).toFixed(2) // '123.34'  期望 123.35

let num1 = 0.615;
console.log(num1.toFixed(2)); // 输出 "0.61" 而非 "0.62"


Math.round 四舍五入到整数 还是不准
Math.round(321201.595 * 100) // 32120159 期望 32120160


```
/**
 * 精确的四舍五入函数
 * @param {number} number - 需要四舍五入的数字
 * @param {number} decimals - 保留的小数位数
 * @returns {number} - 四舍五入后的结果
 */
export function preciseRound(number, decimals = 0) {
  if (typeof number !== 'number' || typeof decimals !== 'number') {
    throw new Error('参数类型错误');
  }
  
  if (decimals < 0) {
    throw new Error('小数位数不能为负数');
  }

  // 处理科学计数法
  const str = number.toString();
  if (str.includes('e')) {
    const [base, exponent] = str.split('e');
    const adjustedNum = Number(base) * Math.pow(10, Number(exponent));
    return preciseRound(adjustedNum, decimals);
  }

  // 将数字转换为字符串并处理小数部分
  let [intPart, decPart = ''] = number.toString().split('.');
  
  // 如果小数部分长度小于要求的精度，补0
  decPart = decPart.padEnd(decimals, '0');
  
  // 如果小数部分长度大于要求的精度，需要进行四舍五入
  if (decPart.length > decimals) {
    // 获取四舍五入位的后一位
    const nextDigit = parseInt(decPart[decimals], 10);
    
    // 构造完整的数字字符串（整数部分 + 需要保留的小数部分）
    let numStr = intPart + (decimals > 0 ? '.' + decPart.slice(0, decimals) : '');
    
    // 如果后一位大于等于5，需要进位
    if (nextDigit >= 5) {
      // 将字符串转换为数字并加上最小单位
      const minUnit = Math.pow(10, -decimals);
      numStr = (parseFloat(numStr) + minUnit).toFixed(decimals);
    }
    
    return numStr;
  }
  
  // 如果小数部分不需要截断，直接返回格式化后的字符串
  return number.toFixed(decimals);
}

```